use compact_str::CompactString;
use crate::ast::{Stmt, Expr, UnaryOp, BinaryOp};
use crate::token::Token;
use crate::lexer::LexicalError;

grammar;

//--------------------------------------------------------

CommaSeparated<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

//--------------------------------------------------------

pub Program: Vec<Stmt> =
    Stmt+;

Stmt: Stmt = {
    <Expr> ";" => Stmt::Expr(<>),
    DefStmt,
};

DefStmt: Stmt =
    "def" <name:Identifier> "(" <params:CommaSeparated<Identifier>> ")" "=" <body:Expr> ";"
        => Stmt::Def(name, params, body);

pub Expr: Expr = {
    Expr4,
    LetExpr,
}

LetExpr: Expr =
    "let" <name:Identifier> "=" <expr1:Expr> "in" <expr2:Expr>
        => Expr::Let(name, Box::new(expr1), Box::new(expr2));

Expr4: Expr = {
    Expr3,
    <lhs:Expr4> "+" <rhs:Expr3> => Expr::BinaryOp(BinaryOp::Add, Box::new(lhs), Box::new(rhs)),
    <lhs:Expr4> "-" <rhs:Expr3> => Expr::BinaryOp(BinaryOp::Sub, Box::new(lhs), Box::new(rhs)),
};

Expr3: Expr = {
    Expr2,
    <lhs:Expr3> "*" <rhs:Expr2> => Expr::BinaryOp(BinaryOp::Mul, Box::new(lhs), Box::new(rhs)),
    <lhs:Expr3> "/" <rhs:Expr2> => Expr::BinaryOp(BinaryOp::Div, Box::new(lhs), Box::new(rhs)),
};

Expr2: Expr = {
    Expr1,
    "-" <Expr1> => Expr::UnaryOp(UnaryOp::Neg, Box::new(<>)),
}

Expr1: Expr = {
    Expr0,
    FunctionApplication,
}

FunctionApplication: Expr =
    <func:Expr0> "(" <args:CommaSeparated<Expr>> ")"
        => Expr::Apply(Box::new(func), args);

Expr0: Expr = {
    Number     => Expr::Number(<>),
    String     => Expr::String(<>),
    Identifier => Expr::Variable(<>),
    "(" <Expr> ")",
};

Number: f64 =
    "number literal";

String: CompactString =
    "string literal";

Identifier: CompactString =
    "identifier";

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token {
        ";" => Token::Semicolon,
        "," => Token::Comma,
        "=" => Token::Equal,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Asterisk,
        "/" => Token::Slash,
        "(" => Token::LParen,
        ")" => Token::RParen,

        "def" => Token::Def,
        "let" => Token::Let,
        "in" => Token::In,

        "number literal" => Token::Number(<f64>),
        "string literal" => Token::String(<CompactString>),
        "identifier" => Token::Identifier(<CompactString>),
    }
}
